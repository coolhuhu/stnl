## 使用一个定时器(timer_fd)管理多个定时事件

使用 timerfd_xxx 系列函数可以很方便的与 select、poll、epoll 等IO复用函数相结合，实现基于事件的定时器功能。大体上有两种实现思路：
- 为每个定时事件创建一个 timer_fd，绑定对应的定时回调函数，然后将 timer_fd 注册到 epoll（或其它IO服用函数）中，当 timer_fd 可读，调用其回调函数，然后关闭该文件描述符。
- 只创建一个 timer_fd。管理所有定时事件，timer_fd 每次只关注时间序列上下一个将要超时的时间，当 timer_fd 变得可读，从管理的所有定时事件中查找比 timer_fd 可读时刻小的定时事件，然后执行对应的回调函数。

这两种方法中，第一种实现起来相对简单，但一个定时事件就对应一个文件描述符，当定时事件较少且创建周期不频繁时，该方法没啥问题；但当定时事件较多，且定时事件的创建和销毁频繁时，会导致文件描述符的频繁创建和关闭，影响服务器性能。第二种方法只使用一个 timer_fd 来管理所有定时事件，能避免文件描述符频繁创建和关闭带来的系统影响，但在实现上相对复杂，关键在于如何高效地管理所有还未超时的定时事件。

下面将具体介绍第二种方法的实现思路和一些实现上的细节，该思路主要来自 muduo 网络库的实现，我尝试对其进行了一点点改进，并将思考一并写在下文。

使用 `timerfd_xxx` 和 `epoll` 实现定时器的功能的主要逻辑如下面的流程图所示，一图胜千言，不再过多的文字解释。

![Pasted image 20240125211402.png](./images/Pasted%20image%2020240125211402.png)

下面介绍一些实现上的细节。

选用什么样的数据结构管理定时事件？对于定时事件的添加、删除和查找，要高效。因为只使用一个 timerfd 来管理多个定时事件，而 timerfd 每次只能关注一个超时时间，若每新添加一个定时事件，就调用 `timerfd_settime` 设置超时事件，会使前面的定时事件失效。因此一个自然的想法是，根据定时事件的超时时间从小到大排序，timerfd 每次只关注所有定时事件中超时时间最小的哪个时间。可以使用C++标准库中的 set 或 map 来管理定时事件，它们是有序集合，底层的数据结构为红黑树，插入、删除和查找的平均时间复杂度都为 O(log *N*)，muduo 中就是使用 set 来管理定时事件的。

muduo 中的做法是，是用 set 来管理定时事件，set 中的元素类型为 `pair<Timestamp，Timer*>`。书中给出了采用这种做法的原因：
“不能直接用map<Timestamp，Timer＊>，因为这样无法处理两个Timer到期时间相同的情况。有两个解决方案，一是用multimap或multiset，二是设法区分key。muduo现在采用的是第二种做法，这样可以避免使用不常见的multimap class。具体来说，以pair<Timestamp，Timer＊>为key，这样即便两个Timer的到期时间相同，它们的地址也必定不同。”

我在写定时器这部分功能时，采用的是 muduo 中提到的第二种方法，使用 multimap 管理定时事件。muduo 中 Timestamp 的精度为微妙，我的实现中 Timestamp 的精度为纳秒，因此几乎不可能存在两个 Timer 到期事件相同的情况，即便存在两个 Timer 到期的 Timestamp 相同，也无妨紧要，因为我在 Timer 类中添加了 TimerId 成员变量，用来唯一标识 Timer，可以通过成员函数来获取该标识。


关于定时事件超时后，处理定时事件上的一些细节。
muduo 源码中，在该部分的实现上，我觉得有一点很值得学习，行文如下。